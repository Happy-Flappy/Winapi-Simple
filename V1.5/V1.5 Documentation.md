# Winsimple Library Documentation

A header-only C++ Windows graphics library that wraps GDI+, WinAPI controls, MCI audio, and clipboard/drag-drop into a clean, easy-to-use API.

```cpp
#include "winsimple.h"
```

**Linker flags:** `-lgdi32 -luser32 -lole32 -lmsimg32 -lkernel32 -lwinmm -lcomctl32 -lgdiplus -lshlwapi -lcomdlg32 -luuid`

All classes and functions live in the `ws::` namespace.

---

## Table of Contents

1. [Core Utilities](#1-core-utilities)
2. [Data Types](#2-data-types)
3. [Sound — `ws::Wav`](#3-sound--wswav)
4. [Graphics](#4-graphics)
   - [ws::View](#41-wsview)
   - [ws::Texture](#42-wstexture)
   - [ws::GIF](#43-wsgif)
   - [ws::Drawable (base)](#44-wsdrawable-base-class)
   - [ws::Sprite](#45-wssprite)
   - [ws::Line](#46-wsline)
   - [ws::Font & ws::Text](#47-wsfont--wstext)
   - [ws::Poly](#48-wspoly)
   - [ws::Radial](#49-wsradial)
   - [ws::Round](#410-wsround)
   - [ws::ShiftData & ws::Shift](#411-wsshiftdata--wsshift)
5. [Window System](#5-window-system)
   - [ws::Window](#51-wswindow)
   - [ws::Cursor](#52-wscursor)
   - [ws::DropTarget](#53-wsdroptarget)
6. [Child Controls](#6-child-controls)
   - [ws::Child (base)](#61-wschild-base)
   - [ws::Button](#62-wsbutton)
   - [ws::TextBox](#63-wstextbox)
   - [ws::Label](#64-wslabel)
   - [ws::Slider](#65-wsslider)
   - [ws::ComboBox](#66-wscombobox)
7. [Menus](#7-menus)
   - [ws::Menu & ws::Dropdown](#71-wsmenu--wsdropdown)
   - [ws::ClickMenu](#72-wsclickmenu)
8. [Clipboard](#8-clipboard)
9. [File Dialogs](#9-file-dialogs)
10. [Global Input](#10-global-input)
11. [Complex Usage Examples](#11-complex-usage-examples)

---

## 1. Core Utilities

### `ws::Timer`

High-resolution timer built on `QueryPerformanceCounter`.

```cpp
ws::Timer timer;
```

| Method | Returns | Description |
|---|---|---|
| `restart()` | `double` | Resets the timer. Returns the elapsed seconds before reset. |
| `getSeconds()` | `double` | Elapsed time in seconds since last restart. |
| `getMilliSeconds()` | `double` | Elapsed time in milliseconds. |
| `getMicroSeconds()` | `double` | Elapsed time in microseconds. |

```cpp
ws::Timer timer;
while (window.isOpen()) {
    double dt = timer.restart(); // delta time in seconds
    x += speed * dt;
}
```

---

### Helper Functions

```cpp
std::wstring ws::WIDE(std::string str);        // UTF-8 string → wide string
std::string  ws::SHORT(const std::wstring& w); // Wide string → UTF-8 string
```

These are used internally throughout the library but are available for your own use whenever you need to interop with wide-string Win32 APIs.

---

## 2. Data Types

Winsimple provides vector and rectangle types that interoperate freely with Win32 structs. All constructors accept any compatible arithmetic type or any struct with matching member names.

### Vector Types

| Type | Members | Notes |
|---|---|---|
| `ws::Vec2i` | `int x, y` | Implicitly converts to/from any `{x, y}` struct and `POINT*` |
| `ws::Vec2f` | `float x, y` | Same conversions |
| `ws::Vec2d` | `double x, y` | Same conversions |
| `ws::Vec3i` | `int x, y, z` | Implicitly converts to/from any `{x, y, z}` struct |
| `ws::Vec3f` | `float x, y, z` | Same conversions |
| `ws::Vec3d` | `double x, y, z` | Same conversions |

```cpp
ws::Vec2i pos(100, 200);
ws::Vec2f vel(1.5f, -3.0f);

// Implicit conversion to Win32 POINT
POINT p = pos;
// Implicit conversion from POINT
POINT winPoint = {50, 75};
ws::Vec2i v = winPoint;
```

### Rectangle Types

| Type | Members | Notes |
|---|---|---|
| `ws::IntRect` | `int left, top, width, height` | Automatically converts from `RECT` (right/bottom style) |
| `ws::FloatRect` | `float left, top, width, height` | Same conversions |
| `ws::DoubleRect` | `double left, top, width, height` | Same conversions |

```cpp
ws::IntRect rect(0, 0, 800, 600); // left, top, width, height

// Convert to Win32 RECT (right/bottom style) automatically
RECT winRect = rect;

// Convert from Win32 RECT
RECT r = {0, 0, 800, 600};
ws::IntRect myRect = r; // width/height are calculated from right-left, bottom-top
```

---

### `ws::Hue`

An RGBA colour type that implicitly converts to and from `Gdiplus::Color` and `COLORREF`.

```cpp
ws::Hue color(255, 128, 0);       // r, g, b — alpha defaults to 255
ws::Hue color(255, 128, 0, 200);  // r, g, b, a
```

**Predefined colours:**

`ws::Hue::red`, `::green`, `::blue`, `::orange`, `::brown`, `::yellow`, `::cyan`, `::purple`, `::pink`, `::grey`, `::black`, `::white`

```cpp
ws::Hue col = ws::Hue::cyan;

Gdiplus::Color gdip = col;  // implicit conversion for GDI+ functions
COLORREF       cr   = col;  // implicit conversion for Win32 functions
```

**Public members:** `int r, g, b, a`

---

## 3. Sound — `ws::Wav`

Wraps the Windows MCI audio API. Supported formats: `.wav`, `.mid`, `.midi`, `.mp3`, `.wma`.

Each `Wav` object owns one **channel** — an integer ID used by MCI to track a playback device. Multiple `Wav` objects can play simultaneously as long as they use different channel IDs. Use `ws::Wav::getFreeChannel()` to find an available one automatically.

```cpp
ws::Wav music;
music.open("theme.mp3", ws::Wav::getFreeChannel());
music.play();
```

### Construction

```cpp
ws::Wav sound;                        // Default — call open() before use
ws::Wav sound("sfx.wav", 0, true);   // path, channel ID, blocking
```

When `blocking` is `true`, calling `play()` while the sound is already playing does nothing. Set it to `false` to allow restarting mid-playback.

---

### Instance Methods

| Method | Returns | Description |
|---|---|---|
| `open(path, channel, blocking)` | `bool` | Loads a file onto a channel. Must be called before `play()`. |
| `play()` | `void` | Starts playback. |
| `stop()` | `void` | Pauses playback. |
| `setVolume(percent)` | `bool` | Volume from 0–100. Not supported for MIDI files. |
| `getVolume()` | `int` | Returns current volume 0–100. |
| `setProgress(seconds)` | `bool` | Seeks to a position. Works whether playing or paused. |
| `getProgress()` | `long` | Current playback position in seconds. |
| `getLength()` | `long` | Total duration in seconds. |
| `isFinished()` | `bool` | True when playback has reached the end. |

### Static Methods

| Method | Returns | Description |
|---|---|---|
| `ws::Wav::PlayFree(path, channel)` | `bool` | One-shot playback without a `Wav` object. |
| `ws::Wav::stop(channel)` | `void` | Pauses the given channel by ID. |
| `ws::Wav::getChannelStatus(channel)` | `string` | Returns `"playing"`, `"stopped"`, `"paused"`, or `"error"`. |
| `ws::Wav::getFreeChannel()` | `int` | Scans channels 0–99 and returns the first one that isn't playing or paused. |

```cpp
// Fire-and-forget sound effect on any free channel
ws::Wav::PlayFree("explosion.wav", ws::Wav::getFreeChannel());
```

---

## 4. Graphics

### 4.1 `ws::View`

Defines a 2D camera. It has two rectangles:

- **World rect** — which region of the game/app world to show.
- **Port rect** — where on the screen to display it.

By default, both are set to the full window size when you call `window.create()`.

```cpp
ws::View view;
view.init(0, 0, 800, 600); // left, top, width, height
window.setView(view);
```

### World Rect — what part of the world to show

| Method | Description |
|---|---|
| `setRect(left, top, width, height)` | Sets the world-space rectangle directly. |
| `getRect()` → `ws::IntRect` | Returns the current world rectangle. |
| `setCenter(x, y)` / `getCenter()` | Pan the view by repositioning its center. |
| `setSize(size)` / `getSize()` | World rectangle dimensions. |
| `move(dx, dy)` | Shifts the world rect by a delta amount. |

### Port Rect — where on screen to render

| Method | Description |
|---|---|
| `setPortRect(left, top, width, height)` | Sets the screen viewport. |
| `getPortRect()` → `ws::IntRect` | Returns the viewport. |
| `setPortCenter(x, y)` / `getPortCenter()` | Repositions the viewport by its center. |
| `setPortSize(size)` / `getPortSize()` | Viewport dimensions. |

### Transform

| Method | Description |
|---|---|
| `setRotation(degrees)` / `getRotation()` | Rotates the entire view in degrees. |
| `setZoom(val)` / `getZoom()` | Zoom level as a power-of-2 scale. `0` = 1:1, `1` = 2× in, `-1` = 2× out. |
| `setPortRotatePoint(x, y)` | Sets the pivot for view rotation in screen space. |
| `setPortRotatePointCenter()` | Convenience: sets the pivot to the centre of the port. |

### Coordinate Conversion

```cpp
// Convert a screen pixel position to a world coordinate
ws::Vec2i world = view.toWorld(screenX, screenY, windowSize);

// Convert a world coordinate to a screen pixel position
ws::Vec2i screen = view.toScreen(worldX, worldY, windowSize);
```

`ws::Window` provides shorthand versions that supply the window size automatically:

```cpp
ws::Vec2i world  = window.toWorld(mouseX, mouseY);
ws::Vec2i screen = window.toScreen(worldX, worldY);
```

---

### 4.2 `ws::Texture`

An RAII wrapper around `Gdiplus::Bitmap`. Supports copy and move semantics.

```cpp
ws::Texture tex;
tex.loadFromFile("image.png");

ws::Texture tex2("image.png"); // constructor shorthand
```

| Method | Returns | Description |
|---|---|---|
| `loadFromFile(path)` | `bool` | Loads PNG, JPG, BMP, GIF, or TIFF. Relative paths resolve from the executable's directory. |
| `loadFromMemory(buffer, size)` | `bool` | Loads from a raw byte buffer in memory. |
| `loadFromBitmapPlus(bitmap)` | `bool` | Copies from an existing `Gdiplus::Bitmap`. |
| `create(w, h, color)` | `bool` | Creates a blank texture. Colour defaults to transparent. |
| `saveToFile(path)` | `bool` | Saves to file. Format determined by extension (png/jpg/bmp/gif/tiff). |
| `isValid()` | `bool` | Returns true if the bitmap pointer is non-null. |
| `getSize()` | `ws::Vec2i` | Width and height in pixels. |
| `getPixel(x, y)` | `Gdiplus::Color` | Reads a single pixel. |
| `setPixel(x, y, color)` | `void` | Writes a single pixel. |

`bitmap` is a public `Gdiplus::Bitmap*` available for direct GDI+ access when needed.

---

### 4.3 `ws::GIF`

Loads and plays animated GIFs frame by frame. Can also be built manually by adding frames in code.

```cpp
ws::GIF gif;
gif.loadFromFile("animation.gif");
gif.setLoop(true);
gif.play();

// In the game loop:
ws::Texture& frame = gif.update(); // advances the animation
sprite.setTexture(frame, false);
window.draw(sprite);
```

| Method | Returns | Description |
|---|---|---|
| `loadFromFile(path)` | `bool` | Loads all frames and per-frame delays from a GIF file. |
| `addFrame(texture, msDelay)` | `void` | Appends a frame and its display duration in milliseconds. |
| `play()` | `void` | Starts or resumes playback from the current frame. |
| `pause()` | `void` | Freezes on the current frame. |
| `stop()` | `void` | Stops and rewinds to frame 0. |
| `update()` | `ws::Texture&` | Advances the animation based on elapsed time. Returns the current frame. **Call once per game loop iteration.** |
| `getTexture()` | `ws::Texture&` | Returns the current frame without advancing. |
| `getFrame(index)` | `ws::Texture*` | Direct access to a frame by index. |
| `getFrameCount()` | `int` | Total number of frames. |
| `getCurrentFrame()` | `int` | Index of the frame currently being shown. |
| `getStatus()` | `string` | `"playing"`, `"paused"`, or `"stopped"`. |
| `setLoop(bool)` / `getLoop()` | | Enable or disable looping. |
| `getFrameDelay(index)` | `double` | Display duration of a frame in milliseconds. |
| `setFrameDelay(index, ms)` | `bool` | Changes a frame's display duration. |
| `setFrame(index, texture)` | `bool` | Replaces a frame's image. |

---

### 4.4 `ws::Drawable` (base class)

Abstract base for all drawable objects. Provides position, size, rotation, scale, and hit-testing. You do not create `Drawable` objects directly — use the subclasses below.

**Public data members:**

| Member | Type | Description |
|---|---|---|
| `x, y, z` | `int` | World position. |
| `width, height` | `int` | Logical size. Often set automatically by the subclass. |
| `scale` | `ws::Vec2f` | Scale multipliers. Negative values flip the object. |
| `origin` | `ws::Vec2i` | Pivot point for rotation and scale, in local coordinates. |
| `rotation` | `float` | Rotation in degrees. |

**Methods:**

| Method | Description |
|---|---|
| `setPosition(x, y)` / `getPosition()` | World-space position. |
| `setSize(w, h)` / `getSize()` | Logical dimensions. |
| `setScale(sx, sy)` / `getScale()` | Scale. |
| `setOrigin(x, y)` / `getOrigin()` | Local pivot point. |
| `setRotation(deg)` / `getRotation()` | Rotation in degrees. |
| `getVisualWidth()` / `getVisualHeight()` | Actual pixel footprint accounting for scale. |
| `getBounds(left, top, right, bottom)` | Axis-aligned bounding box in world space, accounting for scale and rotation. |
| `contains(point)` | `bool` — point-in-shape hit test. |
| `drawGlobal(graphics*)` | Applies the full transform then calls `draw()`. Called automatically by `ws::Window::draw()`. |
| `draw(graphics*)` | **Pure virtual.** Override this to draw your content in local space. |

---

### 4.5 `ws::Sprite`

Draws a rectangular region of a `ws::Texture`. The region can be changed at any time, making it useful for spritesheet animation.

```cpp
ws::Texture tex("hero.png");
ws::Sprite sprite(tex);
sprite.setPosition(100, 100);
sprite.setScale(2.0f, 2.0f);
window.draw(sprite);
```

| Method | Description |
|---|---|
| `setTexture(texture, resize)` | Attaches a texture. If `resize` is `true` (default), width/height are set to match the texture. |
| `setTextureRect(rect)` | Crops the source region (left, top, width, height). Use for spritesheet animation. |
| `getTextureRect()` → `ws::IntRect` | Returns the current source crop. |
| `getTexture()` | Returns the attached texture reference. |
| `hasTexture()` | `bool` — whether a texture is attached. |

**Spritesheet example:**

```cpp
ws::Texture sheet("spritesheet.png");
ws::Sprite sprite(sheet);

ws::ShiftData anim;
anim.delay = 0.1f;
anim.add(0,   0, 64, 64); // frame 0: x=0
anim.add(64,  0, 64, 64); // frame 1: x=64
anim.add(128, 0, 64, 64); // frame 2: x=128

while (window.isOpen()) {
    window.clear();
    sprite.setTextureRect(ws::Shift(anim)); // advance and apply frame
    window.draw(sprite);
    window.display();
}
```

---

### 4.6 `ws::Line`

A line segment between two points.

```cpp
ws::Line line({0, 0}, {400, 300}, 2, Gdiplus::Color(255, 255, 0, 0));
window.draw(line);
```

**Public data members:** `start` (`ws::Vec2i`), `end` (`ws::Vec2i`), `color` (`Gdiplus::Color`), `width` (`int` — pen thickness in pixels).

| Method | Description |
|---|---|
| `intersects(Line& other)` | `bool` — proper segment-vs-segment intersection test. |

---

### 4.7 `ws::Font` & `ws::Text`

`ws::Font` loads a typeface from a file or from the system. `ws::Text` is a `Drawable` that renders styled text using a `ws::Font`.

```cpp
ws::Font font;
font.loadFromFile("myfont.ttf");
// — or —
font.loadFromSystem("Consolas");

ws::Text label(font);
label.setString("Hello, World!");
label.setCharacterSize(24);
label.setFillColor(Gdiplus::Color(255, 255, 255, 255));
label.setBorderColor(Gdiplus::Color(255, 0, 0, 0));
label.setBorderWidth(2);
label.setPosition(50, 50);
window.draw(label);
```

**`ws::Font` methods:**

| Method | Returns | Description |
|---|---|---|
| `loadFromFile(path)` | `bool` | Loads a `.ttf` or `.otf` font file. |
| `loadFromSystem(name)` | `bool` | Loads by system font name, e.g. `"Arial"`, `"Segoe UI"`. |
| `isValid()` | `bool` | True if the font loaded successfully. |
| `getName()` | `string` | The font family name. |

**`ws::Text` methods:**

| Method | Description |
|---|---|
| `setFont(font)` | Attaches a `ws::Font`. |
| `setString(str)` / `getString()` | The text to display. |
| `setCharacterSize(px)` / `getCharacterSize()` | Font size in pixels. |
| `setStyle(Gdiplus::FontStyle)` | `FontStyleRegular`, `FontStyleBold`, `FontStyleItalic`, `FontStyleUnderline`, `FontStyleStrikeout`. |
| `setFillColor(color)` | Text fill colour. |
| `setBorderColor(color)` | Outline colour. |
| `setBorderWidth(px)` | Outline thickness. Set to `0` for no outline. |

> After `draw()` runs, the `width` and `height` members on the `Text` object are updated to reflect the measured text bounds. This is useful for layout calculations.

---

### 4.8 `ws::Poly`

A filled or outlined polygon with any number of vertices. Supports solid colour, texture mapping, open/closed modes, and collision testing.

```cpp
ws::Poly poly;
poly.addVertex(0,   0);
poly.addVertex(100, 0);
poly.addVertex(50,  100);
poly.setFillColor(Gdiplus::Color(255, 0, 150, 255));
poly.setBorderColor(Gdiplus::Color(255, 255, 255, 255));
poly.setBorderWidth(2);
window.draw(poly);
```

**Public data:** `vertices` (`std::vector<ws::Vec2i>`) — can be read or modified directly.

| Method | Description |
|---|---|
| `addVertex(x, y)` | Appends a vertex. |
| `clear()` | Removes all vertices. |
| `vertexCount()` | Number of vertices. |
| `isValid()` | True if there are at least 3 vertices. |
| `getCentroid()` | Average position of all vertices. |
| `getBoundingRect()` | Axis-aligned bounding box. |
| `contains(point)` | Point-in-polygon test using ray casting. |
| `intersects(Line&)` | True if any polygon edge intersects the line. |
| `intersects(Poly&)` | True if the two polygons overlap. |
| `setFillColor(color)` / `getFillColor()` | Interior fill colour. |
| `setBorderColor(color)` / `getBorderColor()` | Edge colour. |
| `setBorderWidth(px)` / `getBorderWidth()` | Edge thickness in pixels. |
| `setFilled(bool)` | Whether to fill the interior. Default: `true`. |
| `setClosed(bool)` | Whether to draw the closing edge from the last vertex back to the first. Default: `true`. |
| `setTexture(texture)` | Maps a `ws::Texture` over the polygon using UV coordinates. |
| `removeTexture()` | Reverts to solid colour rendering. |
| `setUV(vertexIndex, u, v)` | Sets a UV coordinate (0.0–1.0 range) for a specific vertex. |
| `updateTexture()` | Forces the internal texture cache to regenerate on the next draw. |

---

### 4.9 `ws::Radial`

A regular n-sided polygon, useful as a circle approximation.

```cpp
ws::Radial circle;
circle.setRadius(50);
circle.setPointCount(32);      // more points = smoother
circle.setPosition(200, 200); // sets the center
circle.setFillColor(Gdiplus::Color(255, 0, 200, 100));
window.draw(circle);
```

| Method | Description |
|---|---|
| `setRadius(px)` | Circle radius in pixels. |
| `setPointCount(n)` | Number of polygon vertices. Default: `500`. |
| `setPosition(x, y)` | Sets the **center** position. |
| `move(dx, dy)` | Translates the center by a delta. |
| `setFillColor(color)` | Interior colour. |
| `setBorderColor(color)` | Edge colour. |
| `setBorderWidth(px)` | Edge thickness. |
| `getRadius()` | Returns the current radius. |
| `getPosition()` | Returns the center position. |
| `getPointCount()` | Returns the number of vertices. |
| `contains(point)` | `bool` — circular hit test (faster than the polygon version). |

---

### 4.10 `ws::Round`

An axis-aligned ellipse.

```cpp
ws::Round ellipse;
ellipse.setSize(200, 100);
ellipse.setPosition(300, 200);
ellipse.setFillColor(Gdiplus::Color(255, 50, 150, 200));
ellipse.setBorderColor(Gdiplus::Color(255, 255, 255, 255));
ellipse.setBorderWidth(3);
window.draw(ellipse);
```

Size and position are set through the inherited `Drawable` members (`width`, `height`, `x`, `y`).

| Method | Description |
|---|---|
| `setFillColor(color)` | Interior colour. |
| `setBorderColor(color)` | Outline colour. |
| `setBorderWidth(px)` | Outline thickness. |
| `contains(x, y)` or `contains(Vec2i)` | Ellipse-equation hit test. |

---

### 4.11 `ws::ShiftData` & `ws::Shift`

A lightweight frame-based animator for spritesheet textures. Each frame is defined as a rectangle on the sheet. The free function `ws::Shift()` returns the correct rectangle for the current time.

```cpp
ws::ShiftData anim;
anim.delay = 0.12f; // seconds per frame
anim.add(0,   0, 32, 32); // frame 0
anim.add(32,  0, 32, 32); // frame 1
anim.add(64,  0, 32, 32); // frame 2

// In the game loop:
ws::IntRect frameRect = ws::Shift(anim);
sprite.setTextureRect(frameRect);
```

**`ws::ShiftData` public members:**

| Member | Type | Description |
|---|---|---|
| `delay` | `float` | Seconds to display each frame. |
| `currentframe` | `int` | Index of the current frame (read for inspection). |
| `ended` | `bool` | Becomes `true` after the last frame has been shown. Resets automatically on the next cycle. |

**`ws::ShiftData` methods:**
- `add(left, top, width, height)` — appends a frame rectangle.
- `add(ws::IntRect)` — appends a frame rectangle from a rect object.

**`ws::Shift(ShiftData&)`** — free function. Call once per game loop frame. Returns the `ws::IntRect` for the current frame and advances the timer.

---

## 5. Window System

### 5.1 `ws::Window`

The main application window. Manages the GDI+ back buffer, the view/camera, child controls, and the message loop.

```cpp
ws::Window window(800, 600, "My App");
// optional: pass Win32 style flags
ws::Window window(800, 600, "My App", WS_OVERLAPPEDWINDOW, 0);
// deferred creation:
ws::Window window;
window.create(800, 600, "My App");
```

**Standard game loop:**

```cpp
while (window.isOpen()) {
    MSG msg;
    while (window.pollEvent(msg)) {
        // handle input or UI events
    }

    window.clear(Gdiplus::Color(255, 30, 30, 30));
    window.draw(mySprite);
    window.draw(myText);
    window.display();
}
```

### Drawing

| Method | Description |
|---|---|
| `clear(color)` | Clears and recreates the back buffer. Default colour: opaque black. |
| `draw(Drawable&)` | Draws any `Drawable` subclass through the current view transform. |
| `display()` | Blits the back buffer to the screen. Call once per frame after all drawing. |
| `setPixel(x, y, hue)` | Writes a pixel directly to the back buffer. |
| `getPixel(x, y)` | Reads a pixel from the back buffer. Returns `ws::Hue`. |

### Window State

| Method | Description |
|---|---|
| `isOpen()` | Pumps the message queue and returns `false` when the window has been closed. |
| `pollEvent(MSG&)` | Dequeues one pending message. Returns `false` when the queue is empty. |
| `close()` | Destroys the window. `isOpen()` will return `false` next iteration. |
| `setTitle(str)` / `getTitle()` | Window title bar text. |
| `setSize(w, h)` / `getSize()` | Client area size in pixels. |
| `setPosition(x, y)` / `getPosition()` | Screen position of the client area. |
| `setVisible(bool)` / `getVisible()` | Show or hide the window. |
| `setFocus()` / `hasFocus()` | Keyboard focus. |
| `setFullscreen(bool)` / `getFullscreen()` | Toggle borderless fullscreen. The previous size and style are restored when exiting. |
| `setChromaKey(hue)` | Makes a specific colour transparent using a layered window. |

### View & Coordinate Conversion

| Method | Description |
|---|---|
| `setView(view)` / `getView()` | Replaces the window's `ws::View`. |
| `toWorld(x, y)` | Converts screen pixel coordinates to world coordinates. |
| `toScreen(x, y)` | Converts world coordinates to screen pixel coordinates. |

### Win32 Styles

```cpp
window.addStyle(WS_THICKFRAME);
window.removeStyle(WS_MAXIMIZEBOX);
window.addExStyle(WS_EX_TOOLWINDOW);
window.hasStyle(WS_CAPTION);   // returns bool
window.hasExStyle(WS_EX_TOPMOST);
```

### Child Controls

| Method | Description |
|---|---|
| `addChild(child)` | Registers a child control and calls `child.init(*this)`, which creates its HWND. |
| `removeChild(child)` | Unregisters the child without destroying its HWND. |
| `hasChild(child)` | `bool` |

### Public Members

| Member | Type | Description |
|---|---|---|
| `hwnd` | `HWND` | The underlying Win32 window handle. |
| `view` | `ws::View` | The window's camera. |
| `backBuffer` | `ws::Texture` | The off-screen render target. |
| `canvas` | `Gdiplus::Graphics*` | The GDI+ graphics context for the back buffer. Valid between `clear()` and `display()`. |
| `children` | `std::vector<ws::Child*>` | All registered child controls. |

---

### 5.2 `ws::Cursor`

A custom mouse cursor loaded from a system type, a file, or a texture.

```cpp
ws::Cursor cursor(ws::Cursor::Type::Hand);
window.setCursor(cursor);
```

**`ws::Cursor::Type` values:**

| Value | Description |
|---|---|
| `Arrow` | Standard arrow |
| `IBeam` | Text input caret |
| `Wait` | Busy/hourglass |
| `Cross` | Crosshair |
| `Hand` | Pointing hand |
| `SizeAll` | Four-direction move |
| `SizeNS` | Vertical resize |
| `SizeWE` | Horizontal resize |
| `SizeNWSE` | Diagonal resize (↘) |
| `SizeNESW` | Diagonal resize (↙) |
| `No` | Prohibited |
| `Help` | Arrow + question mark |
| `AppStarting` | Arrow + busy |
| `UpArrow` | Upward arrow |
| `Pin` | Pin (Windows 7+) |
| `Person` | Person silhouette (Windows 8+) |
| `Copy` | OLE drag-copy |
| `Move` | OLE drag-move |
| `Link` | OLE drag-link |

| Method | Description |
|---|---|
| `loadAs(Type)` | Loads a system cursor by type. |
| `loadFromFile(path)` | Loads a `.cur` or `.ani` (animated) cursor from a file. |
| `loadFromTexture(texture, hotX, hotY)` | Creates a cursor from a `ws::Texture`. `hotX`/`hotY` is the pixel that acts as the click point. |

---

### 5.3 `ws::DropTarget`

Implements OLE drag-and-drop into a `ws::Window`. Dropped data is queued and retrieved via `pollDrop()`.

```cpp
ws::DropTarget dropTarget;
dropTarget.setWindow(window);      // must be called first
dropTarget.acceptType("files");
dropTarget.acceptType("images");
dropTarget.acceptType("text");
```

**Registration and type control:**

| Method | Description |
|---|---|
| `setWindow(window)` | Registers the drop target with the window via `RegisterDragDrop`. Must be called before any other method. |
| `acceptType(type, effect)` | Enables a drop type. `type` is `"files"`, `"images"`, or `"text"`. `effect` defaults to `ws::DropEffect::Copy`. |
| `rejectType(type)` | Stops accepting a type. |
| `rejectAll()` | Disables all drop types. |
| `onlyAcceptIf(type, fn)` | Conditionally accept drops: `fn` is a `std::function<bool()>` checked on each drag-over event. |

**`ws::DropEffect` enum:** `None`, `Copy`, `Move`, `Link`

**Polling for drops:**

```cpp
ws::ClipData data;
ws::DropEffect effect;
while (dropTarget.pollDrop(data, effect)) {
    std::string              text  = data.getText();
    ws::Texture              image = data.getTexture();
    std::vector<std::string> files = data.getFiles();
}
```

`pollDrop` returns `false` when there are no pending drops. Call it inside your event loop.

---

## 6. Child Controls

All controls inherit from `ws::Child`. Create one, configure it, then pass it to `window.addChild()` to bring it to life.

> Controls can have their position, size, and text set either before or after `addChild()`.

### 6.1 `ws::Child` (base)

**Public data members:** `hwnd`, `controlID`, `backgroundColor`, `textColor`, `borderColor`, `style`, `textStyle`.

| Method | Description |
|---|---|
| `setPosition(x, y)` / `getPosition()` | Control position in client-area coordinates. |
| `setSize(w, h)` / `getSize()` | Control dimensions. |
| `setText(str)` / `getText()` | Control label or content (UTF-8). Reads back live from the HWND if available. |
| `setFont(font, textSettings)` | Sets the displayed font using a `ws::Font` and a `ws::Text` for size/style settings. |
| `addStyle(DWORD)` | Adds a Win32 window style flag. |
| `removeStyle(DWORD)` | Removes a style flag. |
| `hasStyle(DWORD)` | Returns `true` if the flag is currently set. |
| `setFillColor(COLORREF)` | Background colour. |
| `setTextColor(COLORREF)` | Text colour. |
| `setBorderColor(COLORREF)` | Border colour. |

---

### 6.2 `ws::Button`

```cpp
ws::Button btn;
btn.setText("Click Me");
btn.setSize(120, 40);
btn.setPosition(10, 10);
window.addChild(btn);

MSG msg;
while (window.pollEvent(msg)) {
    if (btn.isPressed(msg)) {
        // button was clicked
    }
}
```

| Method | Description |
|---|---|
| `isPressed(MSG&)` | Returns `true` on the frame the button receives a click (`BN_CLICKED`). |

---

### 6.3 `ws::TextBox`

A multiline, scrollable text input field.

```cpp
ws::TextBox box;
box.setSize(300, 100);
box.setPosition(10, 60);
box.setCharacterLimit(500); // 0 = unlimited
window.addChild(box);

std::string content = box.getText();
box.setText("prefilled content");
```

| Method | Description |
|---|---|
| `setCharacterLimit(n)` | Maximum number of characters. `0` = unlimited. |
| `getFocus()` | `bool` — true when the textbox has keyboard focus. |

---

### 6.4 `ws::Label`

Non-interactive static text.

```cpp
ws::Label lbl;
lbl.setText("Status: Ready");
lbl.setSize(200, 24);
lbl.setPosition(10, 170);
window.addChild(lbl);
```

No additional methods beyond `ws::Child`.

---

### 6.5 `ws::Slider`

A horizontal or vertical trackbar.

```cpp
ws::Slider slider;
slider.setSize(300, 30);
slider.setPosition(10, 200);
window.addChild(slider);
slider.setRange(0, 100);
slider.setSlidePosition(50);

MSG msg;
while (window.pollEvent(msg)) {
    if (slider.getScroll(msg)) {
        int value = slider.getSlidePosition();
    }
}
```

| Method | Description |
|---|---|
| `setRange(min, max)` | Sets the minimum and maximum values. |
| `setSlidePosition(pos)` | Moves the thumb programmatically. |
| `getSlidePosition()` | Returns the current thumb position. |
| `getScroll(MSG&)` | `bool` — fires whenever the thumb moves. |
| `setHorizontal()` | Switch to horizontal orientation. |
| `setVertical()` | Switch to vertical orientation. |

---

### 6.6 `ws::ComboBox`

A dropdown selection list, with optional free-text editing.

```cpp
ws::ComboBox combo;
combo.setSize(200, 200); // the height controls dropdown list space
combo.setPosition(10, 240);
combo.addItem("Option A");
combo.addItem("Option B");
combo.addItem("Option C");
window.addChild(combo);

MSG msg;
while (window.pollEvent(msg)) {
    if (combo.selectionChanged(msg)) {
        std::string selected = combo.getSelectedText();
    }
}
```

| Method | Description |
|---|---|
| `addItem(str)` | Appends one list item. Safe to call before `addChild()`. |
| `addItems(vector<string>)` | Appends multiple items at once. |
| `removeItem(index)` | Removes the item at the given index. |
| `clear()` | Removes all items. |
| `getSelectedIndex()` | Returns the selected index, or `-1` if nothing is selected. |
| `setSelectedIndex(n)` | Selects an item programmatically. |
| `getSelectedText()` | Text of the selected list item. |
| `getItemText(index)` | Text of any item by index. |
| `getItemCount()` | Total number of items. |
| `getEditText()` | Text currently shown in the editable field (not necessarily a list item). |
| `setEditText(str)` | Sets the editable field's text. |
| `selectionChanged(MSG&)` | `bool` — fires when the user picks a different item. |
| `setDropdownStyle(allowEdit)` | `true` = editable combo (`CBS_DROPDOWN`), `false` = selection only (`CBS_DROPDOWNLIST`). |

---

## 7. Menus

### 7.1 `ws::Menu` & `ws::Dropdown`

A classic Windows menu bar attached to a window.

```cpp
// Build the dropdowns
ws::Dropdown fileMenu(1, "File");
fileMenu.addItem(101, MF_STRING, "Open");
fileMenu.addItem(102, MF_STRING, "Save");
fileMenu.addItem(0,   MF_SEPARATOR, "");
fileMenu.addItem(103, MF_STRING, "Exit");

ws::Dropdown editMenu(2, "Edit");
editMenu.addItem(201, MF_STRING, "Copy");
editMenu.addItem(202, MF_STRING, "Paste");

// Attach to the window
ws::Menu menuBar;
menuBar.addDropdown(fileMenu);
menuBar.addDropdown(editMenu);
menuBar.setWindow(window);

// Handle commands in the event loop
MSG msg;
while (window.pollEvent(msg)) {
    int cmd = menuBar.getEvent(msg); // returns item ID, or -1
    if (cmd == 101) { /* Open */ }
    if (cmd == 103) { window.close(); }
}
```

**`ws::Dropdown` constructor:** `Dropdown(id, displayName)`

| `Dropdown` Method | Description |
|---|---|
| `addItem(id, type, name)` | Adds an item. `type` is a Win32 flag: `MF_STRING`, `MF_SEPARATOR`, `MF_GRAYED`, etc. |
| `addSubmenu(Dropdown&)` | Nests another `Dropdown` as a submenu. |

**`ws::Menu` methods:**

| Method | Description |
|---|---|
| `addDropdown(Dropdown&)` | Appends a top-level dropdown to the menu bar. |
| `setWindow(window)` | Attaches the menu bar to a window via `SetMenu`. |
| `getEvent(MSG&)` | Returns the selected item ID on a `WM_COMMAND` message, otherwise `-1`. |

---

### 7.2 `ws::ClickMenu`

A right-click context menu that appears at the cursor position.

```cpp
ws::ClickMenu ctx;
ctx.init(window);
ctx.addItem("Copy");
ctx.addItem("Paste");
ctx.addItem("Delete");

MSG msg;
while (window.pollEvent(msg)) {
    if (msg.message == WM_RBUTTONUP) {
        ws::Vec2i mouse = ws::Global::getMousePos(window);
        ctx.show(mouse);
        int cmd = ctx.getCommand(); // 1-based index, 0 if dismissed
        if (cmd == 1) { /* Copy  */ }
        if (cmd == 2) { /* Paste */ }
        if (cmd == 3) { /* Delete */ }
    }
}
```

| Method | Description |
|---|---|
| `init(window)` | Associates with a parent window. Required before `show()`. |
| `addItem(str)` | Appends an item. |
| `removeItem(str)` | Removes the first matching item by name. |
| `setList(vector<string>)` | Replaces all items at once. |
| `getList()` | Returns the current item list. |
| `show(mousePos)` | Displays the popup at the given client coordinates. Blocks until the user selects or dismisses. |
| `getCommand()` | Returns the 1-based index of the last selected item, or `0` if dismissed. |
| `addFlag(DWORD)` / `removeFlag(DWORD)` / `getFlags()` | Modify `TrackPopupMenu` flags, e.g. `TPM_RIGHTBUTTON`. |

---

## 8. Clipboard

Winsimple creates a global `ws::Clipboard` instance called `ws::clipboard` automatically. You do not need to construct one.

```cpp
// --- Writing ---
ws::clipboard.copyText("Hello, clipboard!");
ws::clipboard.copyTexture(myTexture);
ws::clipboard.copyTexture(myTexture, {10, 10, 200, 150}); // copy a region
ws::clipboard.copyFile("C:/path/to/file.png");
ws::clipboard.copyFiles({"file1.png", "file2.png"});
ws::clipboard.clear();

// --- Reading ---
ws::ClipData data = ws::clipboard.paste();
std::string              text  = data.getText();
ws::Texture              image = data.getTexture();
std::vector<std::string> files = data.getFiles();

// --- Checking before reading ---
if (ws::clipboard.hasText())    { ... }
if (ws::clipboard.hasTexture()) { ... }
if (ws::clipboard.hasFiles())   { ... }
```

`ws::ClipData` is a plain data container with `getText()`, `getTexture()`, `getFiles()` getters and matching setters.

---

## 9. File Dialogs

### `ws::FileWindow`

Standard open/save file dialogs.

```cpp
ws::FileWindow dlg;
dlg.setTitle("Choose an image");

if (dlg.open(&window)) {
    std::string path = dlg.getFileName();
    texture.loadFromFile(path);
}

dlg.setFileName("output.png"); // suggest a default filename
if (dlg.save(&window)) {
    texture.saveToFile(dlg.getFileName());
}
```

| Method | Description |
|---|---|
| `setTitle(str)` / `getTitle()` | Dialog title. |
| `setFileName(str)` / `getFileName()` | Pre-fill the filename field / retrieve the result. |
| `addFlag(DWORD)` / `removeFlag(DWORD)` / `getFlags()` | Win32 `OFN_*` flags. |
| `open(window*)` | Shows the Open dialog. Returns `true` on confirm, `false` on cancel. |
| `save(window*)` | Shows the Save dialog. Automatically adds `OFN_OVERWRITEPROMPT`. |

> Always pass `&window` to drain the window's message queue before the dialog blocks.

---

### `ws::FolderWindow`

Standard folder picker dialog.

```cpp
ws::FolderWindow dlg;
dlg.setTitle("Select output folder");
dlg.setInitialFolder("C:/Users");

if (dlg.open(&window)) {
    std::string folder = dlg.getFolderName();
}
```

| Method | Description |
|---|---|
| `setTitle(str)` / `getTitle()` | Dialog title. |
| `setInitialFolder(str)` | Pre-selects this folder when the dialog opens. |
| `getFolderName()` | The chosen folder path. |
| `addFlag(DWORD)` / `removeFlag(DWORD)` / `setFlags(DWORD)` / `getFlags()` | Win32 `BIF_*` flags. |
| `open(window*)` | Shows the picker. Returns `true` on confirm. |

---

## 10. Global Input

These free functions query input state immediately, bypassing the message queue.

```cpp
// Mouse position in a window's client coordinates:
ws::Vec2i pos = ws::Global::getMousePos(window);

// Raw screen coordinates:
ws::Vec2i pos = ws::Global::getMousePos();

// Key or button held (uses Win32 virtual key codes):
bool space  = ws::Global::getButton(VK_SPACE);
bool lmb    = ws::Global::getButton(VK_LBUTTON);
bool rmb    = ws::Global::getButton(VK_RBUTTON);
bool ctrl   = ws::Global::getButton(VK_CONTROL);
bool shift  = ws::Global::getButton(VK_SHIFT);
bool wKey   = ws::Global::getButton('W');
```

`ws::Global::getButton` wraps `GetAsyncKeyState`. It reflects instantaneous hardware state and will detect input even when your window does not have focus.

---

## 11. Complex Usage Examples

### Example 1: Animated Spritesheet with a Scrolling Camera

```cpp
#include "winsimple.h"

int main() {
    ws::Window window(800, 600, "Camera Demo");

    ws::Texture sheet;
    sheet.loadFromFile("character.png");

    ws::Sprite sprite(sheet);
    sprite.setOrigin(16, 32); // pivot at feet

    ws::ShiftData walkAnim;
    walkAnim.delay = 0.1f;
    for (int i = 0; i < 6; i++)
        walkAnim.add(i * 32, 0, 32, 64); // 6 walk frames

    ws::View camera;
    camera.init(0, 0, 800, 600);

    float playerX = 400.f, playerY = 300.f;
    ws::Timer dt;

    while (window.isOpen()) {
        float delta = (float)dt.restart();

        float speed = 200.f * delta;
        if (ws::Global::getButton(VK_RIGHT)) playerX += speed;
        if (ws::Global::getButton(VK_LEFT))  playerX -= speed;
        if (ws::Global::getButton(VK_UP))    playerY -= speed;
        if (ws::Global::getButton(VK_DOWN))  playerY += speed;

        // Keep the camera centred on the player
        camera.setCenter((int)playerX, (int)playerY);
        window.setView(camera);

        sprite.setTextureRect(ws::Shift(walkAnim));
        sprite.setPosition((int)playerX, (int)playerY);

        window.clear(Gdiplus::Color(255, 60, 120, 60));
        window.draw(sprite);
        window.display();
    }
}
```

---

### Example 2: Drag-and-Drop Image Viewer

```cpp
#include "winsimple.h"

int main() {
    ws::Window window(900, 700, "Drop an image here");

    ws::DropTarget drop;
    drop.setWindow(window);
    drop.acceptType("images");
    drop.acceptType("files");

    ws::Texture image;
    ws::Sprite  sprite;
    bool        hasImage = false;

    while (window.isOpen()) {
        MSG msg;
        while (window.pollEvent(msg)) {}

        // Poll for completed drops
        ws::ClipData data;
        ws::DropEffect effect;
        while (drop.pollDrop(data, effect)) {
            bool loaded = false;

            // Prefer inline image data (e.g. dragged from a browser)
            if (data.getTexture().isValid()) {
                image  = data.getTexture();
                loaded = true;
            }
            // Fall back to loading from a file path (e.g. from Explorer)
            else if (!data.getFiles().empty()) {
                loaded = image.loadFromFile(data.getFiles()[0]);
            }

            if (loaded) {
                sprite.setTexture(image);
                hasImage = true;
                window.setTitle(data.getFiles().empty()
                    ? "Dropped image"
                    : data.getFiles()[0]);
            }
        }

        window.clear(Gdiplus::Color(255, 40, 40, 40));

        if (hasImage) {
            // Scale to fit, preserving aspect ratio
            float sx = (float)window.getSize().x / image.getSize().x;
            float sy = (float)window.getSize().y / image.getSize().y;
            float s  = std::min(sx, sy);
            sprite.setScale(s, s);
            sprite.setPosition(0, 0);
            window.draw(sprite);
        }

        window.display();
    }
}
```

---

### Example 3: UI Layout with Controls and a Menu Bar

```cpp
#include "winsimple.h"

int main() {
    ws::Window window(620, 420, "UI Demo");

    // -- Menu bar --
    ws::Dropdown fileMenu(1, "File");
    fileMenu.addItem(101, MF_STRING, "Copy text to clipboard");
    fileMenu.addItem(0,   MF_SEPARATOR, "");
    fileMenu.addItem(102, MF_STRING, "Exit");

    ws::Menu menuBar;
    menuBar.addDropdown(fileMenu);
    menuBar.setWindow(window);

    // -- Controls --
    ws::Label   lbl;
    ws::TextBox input;
    ws::Button  btn;
    ws::Slider  slider;
    ws::ComboBox combo;

    lbl.setText("Enter some text:");
    lbl.setSize(200, 24);
    lbl.setPosition(10, 10);

    input.setSize(580, 80);
    input.setPosition(10, 38);
    input.setCharacterLimit(1024);

    btn.setText("Copy to clipboard");
    btn.setSize(160, 32);
    btn.setPosition(10, 130);

    slider.setSize(400, 30);
    slider.setPosition(10, 175);

    combo.setSize(220, 180);
    combo.setPosition(10, 220);
    combo.addItems({"Sans-serif", "Monospace", "Serif"});

    window.addChild(lbl);
    window.addChild(input);
    window.addChild(btn);
    window.addChild(slider);
    window.addChild(combo);

    ws::Font  font;
    ws::Text  statusText;
    font.loadFromSystem("Segoe UI");
    statusText.setFont(font);
    statusText.setCharacterSize(14);
    statusText.setFillColor(Gdiplus::Color(255, 220, 220, 220));
    statusText.setPosition(10, 360);

    while (window.isOpen()) {
        MSG msg;
        while (window.pollEvent(msg)) {
            // Button click
            if (btn.isPressed(msg)) {
                ws::clipboard.copyText(input.getText());
                statusText.setString("Copied!");
            }

            // Menu commands
            int cmd = menuBar.getEvent(msg);
            if (cmd == 101) {
                ws::clipboard.copyText(input.getText());
                statusText.setString("Copied via menu.");
            }
            if (cmd == 102) window.close();

            // Slider moved
            if (slider.getScroll(msg)) {
                statusText.setString("Slider: " +
                    std::to_string(slider.getSlidePosition()));
            }

            // Combo selection changed
            if (combo.selectionChanged(msg)) {
                statusText.setString("Font style: " +
                    combo.getSelectedText());
            }
        }

        window.clear(Gdiplus::Color(255, 45, 45, 48));
        window.draw(statusText);
        window.display();
    }
}
```

---

### Example 4: Polygon Physics and Texture Mapping

```cpp
#include "winsimple.h"

int main() {
    ws::Window window(800, 600, "Poly Physics");

    ws::Texture groundTex;
    groundTex.loadFromFile("ground.png");

    // A textured ground polygon
    ws::Poly ground;
    ground.addVertex(0,   480);
    ground.addVertex(800, 480);
    ground.addVertex(800, 600);
    ground.addVertex(0,   600);
    ground.setTexture(groundTex);

    // A wall on the right side
    ws::Poly wall;
    wall.addVertex(750, 0);
    wall.addVertex(800, 0);
    wall.addVertex(800, 480);
    wall.addVertex(750, 480);
    wall.setFillColor(Gdiplus::Color(200, 180, 180, 180));

    ws::Radial ball;
    ball.setRadius(18);
    ball.setFillColor(Gdiplus::Color(255, 255, 80, 20));
    ball.setBorderColor(Gdiplus::Color(255, 255, 200, 0));
    ball.setBorderWidth(2);
    ball.setPosition(100, 100);

    float vx = 240.f, vy = 0.f;
    ws::Timer dt;

    while (window.isOpen()) {
        float delta = (float)dt.restart();

        // Gravity
        vy += 600.f * delta;

        ball.move((int)(vx * delta), (int)(vy * delta));
        ws::Vec2i pos = ball.getPosition();

        // Bounce off ground
        if (ground.contains(pos)) {
            vy = -std::abs(vy) * 0.65f;
            vx *=  0.98f;
            ball.move(0, -4);
        }

        // Bounce off wall
        if (wall.contains(pos)) {
            vx = -std::abs(vx);
            ball.move(-6, 0);
        }

        // Wrap around left edge
        if (pos.x < -20) ball.setPosition(820, pos.y);

        window.clear(Gdiplus::Color(255, 100, 160, 220));
        window.draw(ground);
        window.draw(wall);
        window.draw(ball);
        window.display();
    }
}
```

---

### Example 5: Audio Player with a Seek Bar

```cpp
#include "winsimple.h"

int main() {
    ws::Window window(500, 200, "Audio Player");

    ws::Button btnPlay, btnStop;
    ws::Slider seekBar;
    ws::Label  timeLbl;

    btnPlay.setText("Play");
    btnPlay.setSize(80, 32);
    btnPlay.setPosition(10, 10);

    btnStop.setText("Stop");
    btnStop.setSize(80, 32);
    btnStop.setPosition(100, 10);

    seekBar.setSize(460, 30);
    seekBar.setPosition(10, 55);

    timeLbl.setSize(460, 24);
    timeLbl.setPosition(10, 100);

    window.addChild(btnPlay);
    window.addChild(btnStop);
    window.addChild(seekBar);
    window.addChild(timeLbl);

    ws::Wav audio;
    audio.open("music.mp3", ws::Wav::getFreeChannel());
    audio.setVolume(80);

    long total = audio.getLength();
    seekBar.setRange(0, (int)total);

    // Format seconds as mm:ss
    auto fmt = [](long s) -> std::string {
        return std::to_string(s / 60) + ":" +
               (s % 60 < 10 ? "0" : "") + std::to_string(s % 60);
    };

    while (window.isOpen()) {
        MSG msg;
        while (window.pollEvent(msg)) {
            if (btnPlay.isPressed(msg))  audio.play();
            if (btnStop.isPressed(msg))  audio.stop();

            // Dragging the seek bar repositions playback
            if (seekBar.getScroll(msg))
                audio.setProgress(seekBar.getSlidePosition());
        }

        // Keep the seek bar in sync with playback
        long pos = audio.getProgress();
        seekBar.setSlidePosition((int)pos);
        timeLbl.setText(fmt(pos) + " / " + fmt(total) +
            (audio.isFinished() ? "   [Finished]" : ""));

        window.clear(Gdiplus::Color(255, 28, 28, 28));
        window.display();
    }
}
```

---

### Example 6: Pixel Drawing Canvas

```cpp
#include "winsimple.h"

int main() {
    ws::Window window(800, 600, "Pixel Canvas");

    ws::Texture canvas;
    canvas.create(800, 600, Gdiplus::Color(255, 255, 255, 255));

    ws::Sprite canvasSprite(canvas);
    canvasSprite.setPosition(0, 0);

    ws::Hue drawColour = ws::Hue::black;
    int     brushSize  = 4;

    ws::ClickMenu colourMenu;
    colourMenu.init(window);
    colourMenu.addItem("Black");
    colourMenu.addItem("Red");
    colourMenu.addItem("Blue");
    colourMenu.addItem("Green");
    colourMenu.addItem("White (erase)");

    while (window.isOpen()) {
        MSG msg;
        while (window.pollEvent(msg)) {
            if (msg.message == WM_RBUTTONUP) {
                colourMenu.show(ws::Global::getMousePos(window));
                switch (colourMenu.getCommand()) {
                    case 1: drawColour = ws::Hue::black;  break;
                    case 2: drawColour = ws::Hue::red;    break;
                    case 3: drawColour = ws::Hue::blue;   break;
                    case 4: drawColour = ws::Hue::green;  break;
                    case 5: drawColour = ws::Hue::white;  break;
                }
            }
        }

        // Draw with left mouse button
        if (ws::Global::getButton(VK_LBUTTON)) {
            ws::Vec2i mouse = ws::Global::getMousePos(window);
            for (int dy = -brushSize; dy <= brushSize; dy++)
                for (int dx = -brushSize; dx <= brushSize; dx++)
                    canvas.setPixel(mouse.x + dx, mouse.y + dy, drawColour);
            canvasSprite.setTexture(canvas, false);
        }

        // Save on Ctrl+S
        if (ws::Global::getButton(VK_CONTROL) &&
            ws::Global::getButton('S')) {
            ws::FileWindow save;
            save.setTitle("Save drawing");
            save.setFileName("drawing.png");
            if (save.save(&window))
                canvas.saveToFile(save.getFileName());
        }

        window.clear();
        window.draw(canvasSprite);
        window.display();
    }
}
```
